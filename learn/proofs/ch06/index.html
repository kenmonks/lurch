<!-- @format -->

<!doctype html>
<html lang="en">
  <head>
    <title>Predicate Logic and Equality</title>
    <meta charset="utf-8" />
    <meta
      name="description"
      content="This is the home page for lurch.plus, the home of the Lurch proof assistant, plus additional content." />
    <meta
      name="keywords"
      content="Lurch, Lurch plus, proof assistant, math academy, summer courses, math proof camp, math proofs, mathematical proof, proof class, proof course, summer math camp, summer math program, summer math class, math camp, math program, math class, MATHCOUNTS, AMC, AIME, USAMO, IMO, ARML, math contest training, math competition training, math olympiad, AP olympiad, Intel Science, ISEF, ISTS, Regeneron competition, Siemens competition, math gifted, summer school program, camps for kids, academic summer camp, summer academy, summer schools, summer school usa, summer academic programs, summer classes, academy of mathematics, university of scranton, Lehigh Valley ARML" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="shortcut icon" href="../../../assets/media/favicon-L+.svg" />
    <!-- load Font Awesome icon pack 
     see https://fontawesome.com/search?m=free&o=r for more icons
-->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet" />

    <link
      href="//fonts.googleapis.com/css?family=Open+Sans:400,600,400italic,700,300"
      rel="stylesheet"
      type="text/css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&display=swap"
      rel="stylesheet" />

    <link rel="stylesheet" href="../../../assets/css/monks.css" />
    <link rel="stylesheet" href="../../../assets/css/lurchplus.css" />

    <!-- <link rel='stylesheet' href='assets/css/bootstrap.min.css'> -->
  </head>

  <body class="course">
    <div id="leftnav">
      <div id="courseinfo">
        <h1 class="site-title">
          <a
            href="/learn/proofs/"
            target="lurchplus"
            aria-label="Go to course home"
            >Introduction to Mathematical Proof</a
          >
        </h1>

        <div class="byline">
          <a href="mailto:monks@scranton.edu">Ken Monks</a>
        </div>

        <div class="site">
          <a href="https://monks.scranton.edu" target="monks"
            >monks.scranton.edu</a
          >
        </div>
      </div>

      <div id="menu-scroll">
        <ul class="side-nav"
          ><li> <a href="/learn/proofs/">1: Introduction</a> </li
          ><li> <a href="/learn/proofs/ch02/">2: What is a proof?</a> </li
          ><li>
            <a href="/learn/proofs/ch03/"
              >3: The Language of Mathematics</a
            > </li
          ><li>
            <a href="/learn/proofs/ch04/"
              >4: Reasoning about Mathematics</a
            > </li
          ><li> <a href="/learn/proofs/ch05/">5: Propositional Logic</a> </li
          ><li class="active">
            <a href="/learn/proofs/ch06/">6: Predicate Logic and Equality</a>
          </li>
        </ul>
      </div>

      <div class="sidebar-powered">
        <a
          href="/"
          class="powered-link"
          target="lurchplus"
          rel="noopener noreferrer">
          <span class="powered-label">powered by</span>
          <img
            src="/assets/media/lurchlogo.png"
            alt="Lurch"
            class="powered-logo" />
        </a>
      </div>
    </div>

    <!-- flex column for content-block and footer-block -->
    <div id="wrap">
      <div id="content-block" class="problems" style="--chapter: '6'">
        <div class="title-box">
          <h1>Chapter 6: Predicate Logic</h1>
        </div>
        <p
          >We can extend Propositional Logic by adding more statements and rules
          of inference to those we already have in our formal system. This
          extended formal system is called <em>Predicate Logic</em>.</p
        >
        <h2>Bound variables and lambda expressions</h2>
        <p
          >Many math expressions contain identifiers which are variables that
          have no meaning outside of the expression. For example, in an
          expression like $\sum_{k=0}^n k^3$, the variable $k$ is bound to the
          expression in the sense that has no meaning outside the expression
          itself. Indeed, we can replace it with any other letter that is not
          declared to be a constant to obtain an expression with the exact same
          meaning, like $\sum_{i=0}^n i^3$.</p
        >
        <div class="Def">
          <p
            ><strong class="qu">Definition <span class="thm"></span>.</strong> A
            <em>binding</em> is an expression of the form $x.E$ where $x$ is any
            non-constant identifier and $E$ is any expression. All occurrences
            of $x$ in $x.E$ are said to be <em>bound variables</em>. All
            identifiers in $x.\varphi$ other than constants or bound variable
            are called <em>free variables</em>. An operator applied to a binding
            is called a <em>quantifier</em>.</p
          >
        </div>
        <p
          >We can apply a constant operator $\lambda$ to a binding expression
          $x.E$ to form the expression $\lambda x.E$ called
          <em>lambda expressions</em>. Such expressions can be applied to an
          expression $a$ to form a new expression, $(\lambda x.E)(a)$. Another
          name for a lambda expression is <em>anonymous function</em> and they
          can also be written as $x\mapsto E$.</p
        >
        <p
          >These can be <em>evaluated</em> to form the expression obtained by
          replacing all occurrences of $x$ in $E$ with $(a)$ (no free identifier
          in $a$ should become bound as a result of the substitution). If we
          give a name to an anonymous function, e.g., if we define $f$ to be
          $\lambda x.E$ then the expression $(\lambda x.E)(a)$ is just the usual
          prefix notation for function application $f(a)$. In this situation we
          refer to $a$ as the argument of the anonymous function application.</p
        >
        <p
          >For example, $(x\mapsto x^3)(a)$ evaluates to $a^3$. Indeed, in many
          math textbooks they will write $f(x)=x^3$ instead of $f=(x \mapsto
          x^3)$, but the latter is usually what they mean. In this example, we
          have the usual evaluation of functions, e.g., $f(a)=a^3$, $f(2)=2^3$,
          and $f(x+1)=(x+1)^3$.</p
        >
        <p
          >Notice that simply replacing all occurrences of $x$ in $\lambda x.E$
          with another identifier that does not appear in $E$ produces a new
          lambda expression which evaluates to the same thing as the original
          lambda expression when applied to the same argument. Such lambda
          expressions are said to be <em>$\alpha$-equivalent</em>.</p
        >
        <h2>Quantifiers and Statements of Predicate Logic</h2>
        <p
          >Predicate logic extends propositional logic by defining two
          additional quantifiers.</p
        >
        <div class="Def">
          <p
            ><strong class="qu">Definition <span class="thm"></span>.</strong>
            The symbols $\forall$ and $\exists$ are <em>quantifiers</em>. The
            symbol $\forall$ is called “for all”, “for every”, or “for each”.
            The symbol $\exists$ is called “for some” or “there exists”.</p
          >
        </div>
        <p>We will encounter more quantifiers beyond just these two.</p>
        <p
          >Every statement of Propositional Logic is still a statement of
          Predicate Logic. In addition, we define the following new
          statements.</p
        >
        <div class="Def">
          <p
            ><strong class="qu">Definition <span class="thm"></span></strong> If
            $x$ is any variable and $\mc{W}(x)$ any statement that results from
            evaluating a lambda expression $W$ on $x$ when applied to any
            expression having the same type as $x$, then $(\forall x.\mc{W}(x))$
            and $(\exists x.\mc{W}(x))$ are both statements.</p
          >
        </div>
        <p
          >We say that the <em>scope</em> of the quantifier in $(\forall
          x.W(x))$ and $(\exists x.W(x))$ is everything inside the outer
          parentheses. Sometimes the outer parentheses are omitted when the
          scope is clear from context. All occurrences of $x$ throughout the
          scope are said to be bound by the quantifier.</p
        >
        <h2>Declarations</h2>
        <p
          >In addition to declaring global constants in our proofs we will also
          need to be able to introduce new identifiers into our proofs. Just
          like all expressions and environments, we will have one declaration
          that is an assumption and one that is a claim.</p
        >
        <div class="Def">
          <p
            ><strong>Definition <span class="thm"></span></strong><br />
            A <em>let declaration</em> is an expression of the form</p
          >
          <div class="display">
            <p
              ><code>Let</code> $x_1,\ldots x_n$
              <code>be such that</code> $W$</p
            >
          </div>
          <p>A <em>for-some-declaration</em> is an expression of the form</p>
          <div class="display">
            <p>$W$ <code>for some</code> $x_1,\ldots x_n$</p>
          </div>
          <p
            >In both declarations $x_1,\ldots x_n$ must be new identifiers at
            that point in the proof, and $W$ is called the <em>body</em> of the
            declaration. The scope of each declaration starts at the declaration
            and continues until the end of the environment containing it.</p
          >
        </div>
        <p
          >A let-declaration is an assumption that we can name arbitrary things
          that satisfy the statement $W$. If the phrase
          <code>be such that</code> $W$ is omitted then a let-declaration is
          just the assumption that $x_1,\ldots x_n$ are completely arbitrary
          unspecified things with no restrictions. A for-some-declaration is a
          claim that we can name arbitrary unspecified things that we know exist
          and satisfy the statement $W$.</p
        >
        <p
          >Bound variables do not have to be declared. They can be any
          identifier you like, as long as that identifier is not in the scope of
          a constant declaration or more than one binding expression that binds
          it.</p
        >
        <h3>Let-environments</h3>
        <p
          >Since a let-declaration is an assumption, it can be the premise of a
          special kind of if-then environment.</p
        >
        <div class="Def">
          <p
            ><strong class="qu">Definition <span class="thm"></span>.</strong> A
            <em>let-environment</em> is an if-then environment containing a
            let-declaration followed by one or more claims.</p
          >
        </div>
        <p
          >Note that a let-environment will usually not have additional
          assumptions after the initial let-declaration because usually we will
          want such assumptions to be included in the body.</p
        >
        <h2>Rules of Predicate Logic</h2>
        <p
          >Following Gentzen, we have an introduction and elimination rule for
          each of the two logical quantifiers.</p
        >
        <div class="table-block">
          <p class="table-title">Rules of Propositional Logic</p>
          <table>
            <thead>
              <tr>
                <th style="text-align: left">Name</th>
                <th style="text-align: left">Rule</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td style="text-align: left">$\forall+$</td>
                <td style="text-align: left"
                  >$(\xlet s \vdash \mc{W}(s)) \vdash \forall x.\mc{W}(x)$</td
                >
              </tr>
              <tr>
                <td style="text-align: left">$\forall-$</td>
                <td style="text-align: left"
                  >$(\forall x.\mc{W}(x)) \vdash \mc{W}(t)$</td
                >
              </tr>
              <tr>
                <td style="text-align: left">$\exists+$</td>
                <td style="text-align: left"
                  >$\mc{W}(t) \vdash \exists x.\mc{W}(x)$</td
                >
              </tr>
              <tr>
                <td style="text-align: left">$\exists-$</td>
                <td style="text-align: left"
                  >$(\exists x.\mc{W}(x)) \vdash \mc{W}(c)\forsome x$</td
                >
              </tr>
            </tbody>
          </table>
        </div>
        <!-- table-block -->
        <div class="">
          <p
            >We can also list these rules in if-then rule notation that mirrors
            how they are used in proofs.</p
          >
          <div class="rule-set">
            <div class="rule-set-head">
              <p>Definition of Quantifiers</p>
              <p
                ><a
                  href="../../../student.html?load=learn/proofs/rules/Pred.lurch"
                  class="lurch-open lurch-link"
                  target="_blank"
                  rel="noopener"
                  aria-label="Use in Lurch (opens in new tab)">
                  <span class="lurch-open__label">Use in Lurch</span>
                  <i
                    class="fa-solid fa-arrow-up-right-from-square lurch-open__icon"
                    aria-hidden="true"></i> </a
              ></p>
              <!-- rule-set-head -->
            </div>
            <p
              ><span class="m">Declare $\forall$, $\exists$</span> to be
              constants.</p
            >
            <div class="rule-grid cols-2">
              <div class="Rule">
                <p><span class="nm">$\forall+$</span></p>
                <div class="Premise">
                  <p><em>Given</em></p>
                  <div class="Subproof">
                    <p
                      ><span class="m">Let $s$</span> be arbitrary.<br />
                      <span class="m">$\mc{W(x)}$</span></p
                    >
                  </div>
                </div>
                <p
                  ><em>Conclude</em>
                  <span class="m">$\forall x.\mc{W(x)}$</span></p
                >
              </div>
              <div class="Rule">
                <p><span class="nm">$\forall-$</span></p>
                <div class="Premise">
                  <p
                    ><em>Given</em><br />
                    <span class="m">$\forall x.\mc{W(x)}$</span></p
                  >
                </div>
                <p><em>Conclude</em> <span class="m">$\mc{W(t)}$</span></p>
              </div>
              <div class="Rule">
                <p><span class="nm">$\exists+$</span></p>
                <div class="Premise">
                  <p
                    ><em>Given</em><br />
                    <span class="m">$\mc{W(t)}$</span></p
                  >
                </div>
                <p
                  ><em>Conclude</em>
                  <span class="m">$\exists x.\mc{W(x)}$</span></p
                >
              </div>
              <div class="Rule">
                <p><span class="nm">$\exists-$</span></p>
                <div class="Premise">
                  <p
                    ><em>Given</em><br />
                    <span class="m">$\exists x.\mc{W(x)}$</span></p
                  >
                </div>
                <p
                  ><em>Conclude</em>
                  <span class="m">$\mc{W(c)}\forsome c$</span></p
                >
              </div>
              <!-- rule-grid -->
            </div>
            <div class="rule-set-remarks">
              <p class="smallskip"><em>Restrictions and Remarks:</em></p>
              <ul class="disc">
                <li
                  >In $\forall+$ the metavariable $s$ must be replaced by a new
                  identifier in the proof, not a compound expression. The
                  conclusion $\forall x.\mc{W}(x)$ cannot appear in the scope of
                  the declaration of $s$.</li
                >
                <li
                  >In $\forall-$ and $\exists+$ the metavariable $t$ can be
                  replaced by compound expressions, not just identifiers. No
                  free variable in $t$ may become bound when $t$ is substituted
                  for $x$ in $\mc{W}(x)$ (this is true about applying lambda
                  expressions in general).</li
                >
                <li
                  >In $\exists+$ the expression $\mc{W(t)}$ can be the
                  expression obtained by replacing one or more of the
                  occurrences of $t$ with $x$, not necessarily every occurrence
                  (by judiciously choosing $\mc{W}$</li
                >
                <li
                  >In $\exists-$ the metavariable $c$ must be replaced by a new
                  identifier in the proof, not a compound expression.</li
                >
              </ul>
              <!-- rule-set-remarks -->
            </div>
            <!-- rule-set -->
          </div>
          <h2>Equality</h2>
          <p
            >Finally, we can complete our definition of logic by adding the
            rules of inference for equality. This definition was first
            introduced by Leibniz.</p
          >
          <div class="table-block">
            <p class="table-title">Definition of $=$</p>
            <table>
              <thead>
                <tr>
                  <th style="text-align: left">Name</th>
                  <th style="text-align: left">Rule</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td style="text-align: left">reflexivity</td>
                  <td style="text-align: left">$x=x$</td>
                </tr>
                <tr>
                  <td style="text-align: left">substitution</td>
                  <td style="text-align: left"
                    >$(x=y),W\vdash,W$ with one or more free occurrences of $x$
                    replaced by $y$</td
                  >
                </tr>
              </tbody>
            </table>
          </div>
          <!-- table-block -->
        </div>
        <p
          >As usual we can also list these rules in if-then rule notation that
          mirrors how they are used in proofs.</p
        >
        <div class="rule-set">
          <div class="rule-set-head">
            <p>Definition of equals</p>
            <p
              ><a
                href="../../../student.html?load=learn/proofs/rules/Pred.lurch"
                class="lurch-open lurch-link"
                target="_blank"
                rel="noopener"
                aria-label="Use in Lurch (opens in new tab)">
                <span class="lurch-open__label">Use in Lurch</span>
                <i
                  class="fa-solid fa-arrow-up-right-from-square lurch-open__icon"
                  aria-hidden="true"></i> </a
            ></p>
            <!-- rule-set-head -->
          </div>
          <p><span class="m">Declare =</span> to be a constant.</p>
          <div class="rule-grid cols-2">
            <div class="Rule">
              <p
                ><span class="nm">Reflexivity</span><br />
                <em>Conclude</em> <span class="m">$x=x$</span></p
              >
            </div>
            <div class="Rule">
              <p><span class="nm">Substitution</span></p>
              <div class="Premise">
                <p
                  ><em>Given</em><br />
                  <span class="m">$x=y$</span><br />
                  <span class="m">$W$</span></p
                >
              </div>
              <p
                ><em>Conclude</em> <span class="m">$W$</span> with one or more
                free occurrences of $x$ replaced by $y$</p
              >
            </div>
            <!-- rule-grid -->
          </div>
          <div class="rule-set-remarks">
            <p class="smallskip"><em>Restrictions and Remarks:</em></p>
            <ul class="disc">
              <li
                >Notice that in the Reflexive rule there are no inputs, so you
                can insert a statement of the form $x=x$ into your proof at any
                time.</li
              >
              <li
                >In the substitution rule, the metavariables $x$ and $y$ can be
                replaced by compound expressions, not just identifiers. No free
                variable in $W$ may become bound when $x$ is replaced by $y$ in
                $W$.</li
              >
            </ul>
            <!-- rule-set-remarks -->
          </div>
          <!-- rule-set -->
        </div>
        <h2>Problems</h2>
        <p
          >Prove each of the following theorems with a formal proof in our
          system of Natural Deduction. In all of these, $P,Q,R$ are statements
          (or lambda expressions that return a statement) and the variables
          $x,y,z$ etc. are of the same unspecified type.</p
        >
        <h3>Predicate Logic</h3>
        <div class="question">
          <p
            ><span class="thm">distributivity</span> $(\forall x.P(x) \xand
            Q(x)) \iff (\forall y.P(y)) \xand (\forall z.Q(z))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">distributivity</span> $(\exists x.P(x) \xor Q(x))
            \iff (\exists y.P(y)) \xor (\exists z.Q(z))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">distributivity</span> $(\exists x.P(x) \implies
            Q(x)) \iff (\forall y.P(y)) \implies (\exists z.Q(z))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">equivalent predicates</span> $(\forall x.P(x)
            \iff Q(x)) \implies ((\exists x.P(x))\implies (\exists x.Q(x)))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">commutativity</span> $(\forall x.\forall
            y.P(x,y)) \implies (\forall y.\forall x.P(x,y))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">commutativity</span> $(\exists x.\exists
            y.P(x,y)) \implies (\exists y.\exists x.P(x,y))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">one for all</span> $(\exists y.\forall x.P(x,y))
            \implies (\forall x.\exists y.P(x,y))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">some are the same</span> $(\forall x.\forall y.
            P(x,y)) \implies \forall z. P(z,z)$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">De Morgan</span> $\neg (\exists x.P(x)) \iff
            (\forall x. \neg P(x))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">De Morgan</span> $\neg (\forall x.P(x)) \iff
            (\exists x. \neg P(x))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">quantifier fun</span> $\left(\forall x. P(x)
            \implies Q(x)\right) \xand \left(\forall x.\neg Q(x)\right) \implies
            \left(\forall x. \neg P(x)\right)$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">more quantifier fun</span> $(\forall x. P(x) \xor
            Q(x)) \xand (\exists y. \neg P(y)) \implies (\exists z. Q(z))$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">less than, for example</span> $$(\forall x. \neg
            P(x, x)) \xand (\forall x. \forall y. \forall z. P(x, y) \xand P(y,
            z) \implies P(x, z)) \implies (\forall x. \forall y. \neg (P(x, y)
            \xand P(y, x)))$$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">excluded middle</span> $(\forall x.P(x)) \xor
            (\exists x.\neg P(x))$</p
          >
        </div>
        <p class="medskip"></p>
        <p class="medskip"
          >In the next three theorems, $P$ is a statement not containing $x$.</p
        >
        <div class="question">
          <p
            ><span class="thm">de-quantify</span> $(\exists x.Q(x) \xand P) \iff
            (\exists x.Q(x)) \xand P$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">de-quantify</span> $(\forall x.Q(x) \xor P) \iff
            (\forall x.Q(x)) \xor P$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">de-quantify</span> $(\forall x.Q(x) \implies P)
            \iff (\exists x. Q(x)) \implies P$</p
          >
        </div>
        <h3>Equality</h3>
        <div class="question">
          <p
            ><span class="thm">symmetry of equality</span> $x=y \implies y=x$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">avoiding vacuous types</span> $(\exists x. x=x)
            \xand (\forall y. P(y)) \implies \exists z. P(z)$</p
          >
        </div>
        <div class="question">
          <p
            ><span class="thm">alternate definitions of unique existence</span>
            $(\exists x,P(x)\xand \forall y.P(y)\implies y=x) \iff (\exists
            x.P(x) \xand \forall y.\neg(y=x) \implies \neg P(y))$</p
          >
        </div>
        <div class="question">
          <p
            >Let $L(x,y)$ be the statement “$x$ loves $y$” and the domain of
            discourse of all quantified variables be the set of all people.
            Write each of the following English statements using only
            <code>and</code>, <code>or</code>, $\neg$, $\implies$, $\iff$,
            $\forall$, $\exists$, $\exists!$, $L$, $=$, the bound variables $x$
            and $y$ and the constants (names of people) given in the sentences.
            For example, we could express “Everyone loves Bob.” as “$\forall
            x.L(x,\text{Bob})$”.</p
          >
          <div class="parts">
            <ol>
              <li>Alice loves everyone.</li>
              <li>Someone loves Alice.</li>
              <li>Bob loves Alice, but she does not love him.</li>
              <li>Everyone loves someone.</li>
              <li>There is only one person who loves everyone.</li>
              <li>Someone loves everyone.</li>
              <li>There is a person who is loved by only one person.</li>
              <li>Some people do not love themselves.</li>
              <li>Some people only love themselves.</li>
              <li>Nobody loves everybody.</li>
              <li
                >If everyone loves themselves, then everyone loves someone.</li
              >
              <li
                >If two people love each other, then everyone loves them
                both.<br />
                (Note: In English, when “two” is used in this context it usually
                means “two distinct”.)</li
              >
            </ol>
          </div>
          <!-- question -->
        </div>
        <div class="question">
          <p
            >Let $P(x,y)$ be the statement `$x$ is the parent of $y$’ and the
            domain of discourse of all quantified variables be the set of all
            people. What do each of the following say in English?</p
          >
          <div class="parts cols-3">
            <ol>
              <li>$\forall x.\forall y.P(x,y)$</li>
              <li>$\forall x.\exists y.P(x,y)$</li>
              <li>$\exists x.\forall y.P(x,y)$</li>
              <li>$\exists x.\exists y.P(x,y)$</li>
              <li>$\forall x.\exists! y.P(x,y)$</li>
              <li>$\exists! x.\forall y.P(x,y)$</li>
              <li>$\exists x.\exists! y.P(x,y)$</li>
              <li>$\exists! x.\exists! y.P(x,y)$</li>
              <li>$\forall y.\forall x.P(x,y)$</li>
              <li>$\forall y.\exists x.P(x,y)$</li>
              <li>$\exists y.\forall x.P(x,y)$</li>
              <li>$\exists y.\exists x.P(x,y)$</li>
              <li>$\forall y.\exists! x.P(x,y)$</li>
              <li>$\exists! y.\forall x.P(x,y)$</li>
              <li>$\exists y.\exists! x.P(x,y)$</li>
              <li>$\exists! y.\exists! x.P(x,y)$</li>
            </ol>
          </div>
          <!-- question  -->
        </div>
        <div class="question">
          <p
            >Given the first two statements, is the conclusion valid? If not,
            describe a situation where the conclusion is false. If it is,
            formalize the argument and give a formal proof.</p
          >
          <pre><code>  Everyone fears Dracula.  
  Dracula only fears me.  
  Therefore, I *am* Dracula!
</code></pre>
        </div>
        <div class="question">
          <p
            >A function $f$ that maps the positive real numbers to other
            positive real numbers is said to be <em>continuous</em> (C) if and
            only if $$\forall \varepsilon, \forall x.\exists \delta,\forall y.
            \left|x-y\right|&lt;\delta \implies
            \left|f(x)-f(y)\right|&lt;\varepsilon$$ Similarly, $f$ is said to be
            <em>uniformly continuous</em> (UC) if and only if $$\forall
            \varepsilon,\exists \delta, \forall x.\forall y.
            \left|x-y\right|&lt;\delta \implies \left|f(x)-f(y)\right|&lt;
            \varepsilon$$ (all identifiers other than $f$ have type “positive
            real”).</p
          >
          <div class="parts">
            <ol>
              <li
                >Give a formal proof that every uniformly continuous function is
                continuous.</li
              >
              <li
                >Find an example of a function $f$ that is continuous but not
                uniformly continuous.</li
              >
            </ol>
          </div>
          <p
            >Note: You can use the fact that the real numbers are closed under
            multiplication, that constants like, $3$, $\pi$, $\sqrt{2}$, $4/5$
            are real numbers and properties of real number arithmetic, like
            $1+1=2$, or $x+x=2x$, justifying these with the black-box reason
            <span class="m">by arithmetic</span>.</p
          >
        </div>
      </div>

      <div id="footer-block">
        <footer class="microfooter" aria-label="Site footer">
          <span class="microfooter__copyright"> © Kenneth G. Monks </span>

          <span class="microfooter__sep" aria-hidden="true">•</span>

          <a
            class="microfooter__link"
            href="https://monks.scranton.edu"
            target="_blank"
            rel="noopener noreferrer">
            monks.scranton.edu
          </a>

          <span class="microfooter__sep" aria-hidden="true">•</span>

          <a
            class="microfooter__link"
            href="https://lurch.plus"
            target="_blank"
            rel="noopener noreferrer">
            lurch.plus
          </a>

          <span class="microfooter__sep" aria-hidden="true">•</span>

          <a
            class="microfooter__link"
            href="https://proveitmath.org"
            target="_blank"
            rel="noopener noreferrer">
            Prove it! Math Academy
          </a>
        </footer>
      </div>
    </div>

    <script>
      if (!window.name) window.name = 'intro-to-proof'</script
    ><script src="../../../assets/js/utils.js"></script>
    <script src="../../../assets/js/mathjax-config.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
      id="MathJax-script"></script>
  </body>
</html>
